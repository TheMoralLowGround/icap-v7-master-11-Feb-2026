import traceback

from rabbitmq_publisher import publish
from redis_utils import get_redis_data, set_redis_data

from app.json_chunking import json_chunking_main
from app.key_central.key_module_central import (
    extract_anchor_thresholds,
    extraction_tools_request,
)
from app.misc_modules.unique_id import assign_unique_id_helper
from app.rules_normalizers_module.table_rules_centre import get_first_valid_row

"""
API script that handles table keys section for pdf doctypes.
There are specific rules on how to display the values for specific columns.
Also it takes into account any table data generated by docbuilder and also none label handling.
It also handles single-column extractor field and regex type fields where there are multiple values spanning multiple rows.
"""


def get_replacement_value(y):
    tuple_set_1 = ("weight", "volume", "count")
    all_rows_copy = [
        "goodsdescription",
        "requirestemperaturecontrol",
        "commoditycode",
        "requiredmaximum",
        "requiredminimum",
        "temperatureuom",
    ]
    all_rows_copy_endswith = "weightuom"

    label = y["label"].lower()

    if label.endswith(tuple_set_1):
        # weight volumes and counts will be set to zero assuming it is a total
        return "0"
    elif (label in all_rows_copy) or (label.endswith(all_rows_copy_endswith)):
        # Eg. goodsDescription has to be reflected in all the rows
        return y["v"]
    else:
        # Rest of the type of labels will be empty

        return ""


def already_present_function(row, label):
    """Function that check if a cell with input label is already present on the row"""
    cells = row["children"]
    for idx, a in enumerate(cells):
        if a["label"] == label:
            return True, idx
    return False, None


def get_max_cell_count_of_a_label(input_dict_list):
    max_child_length = 0
    for key, value in input_dict_list.items():
        if len(value) > max_child_length:
            max_child_length = len(value)
    return max_child_length


def initiate_blank_row():
    output_dict = dict()
    output_dict["pos"] = ""
    output_dict["type"] = "row"
    output_dict["pageId"] = ""
    output_dict["STATUS"] = 0
    output_dict["children"] = []
    return output_dict


def update_table_with_populated_new_rows(
    multiples_storage, max_child_length, table_children
):
    # This returns, say, we extracted 5 dimensions using anchors in table keys. So, we need 5 rows in tables which are now not present
    for y in range(max_child_length):
        try:
            index_present = table_children[y]
        except:
            blank_row = initiate_blank_row()
            table_children.append(blank_row)

    for label, cell_list in multiples_storage.items():
        for cell_idx, cell in enumerate(cell_list):
            table_children[cell_idx]["children"].append(cell)

    return table_children


def extract_totals_from_cells(cell_list):
    to_be_created_labels = list()
    tuple_set_1 = ("weight", "volume", "count")
    for cell in cell_list:
        if cell.get("label").lower().endswith(tuple_set_1) and cell.get(
            "table_key_generated"
        ):
            if not cell.get("originates_from_multiples"):
                to_be_created_labels.append(cell.get("label"))
    return to_be_created_labels


def extract_totals_from_first_row(table):
    to_be_created_labels = list()
    if table.get("children"):
        for row in table.get("children")[0]:
            if row:
                cells = row.get("children")
                tuple_set_1 = ("weight", "volume", "count")
                for cell in cells:
                    if cell.get("label").lower().endswith() in tuple_set_1 and cell.get(
                        "table_key_generated"
                    ):
                        if not cell.get("originates_from_multiples"):
                            to_be_created_labels.append(cell.get("label"))

    return to_be_created_labels


def not_none_checker(input_cell):
    """Cheks if a cell label is invalid/not in use"""
    label = input_cell["label"]
    if label in ["None", "notInUse", ""] or (label[-1].isnumeric()):
        try:
            if input_cell["parser_generated"]:
                return True
        except:
            pass
        return False

    return True


def check_if_empty_row(cells):
    # Checking if the row is an invalid one
    empty_row = True
    for x in cells:
        if not_none_checker(x):
            empty_row = False
            try:
                if x["parser_generated"]:
                    empty_row = True
            except:
                pass

    return empty_row


def process_table_keys(request_data):
    try:
        # Version = 6.00.07022024
        # @Emon on 24/09/2022: Initiated the script
        # @Emon on 01/10/2022: Bug#01102022.01 - grossWeight unnecessary repetion in empty rows bug fixed
        # @Emon on 01/10/2022: Bug#01102022.02 - key fields do not show if columns are left empty
        # @Emon on 01/10/2022: Upgration.01 - Keys will still be displayed if no table was initiated
        # @Emon on 01/10/2022: Upgration.02 : GoodsDescription, CommodityCode, Temp related fields are to be repeated in all rows
        # @Emon on 06/10/2022: Bug@06102022.01 : Table keys will not display if the table node previously present has empty children
        # @Emon on 12/10/2022 : Weight UOM repeated in all rows
        # @Emon on 14/10/2022: First valid row finder added
        # @Emon on 15/10/2022 : Messages variable added to extraction function
        # @Emon on 30/12/2022 : Added multiple extraction data to tables generating blank rows
        # @Emon on 02/02/2022 : Multiples will also take totals set as 0
        job_id = request_data["job_id"]
        request_data = get_redis_data(job_id)
        request_data["job_id"] = job_id
        d_json = request_data["data_json"]
        print("ðŸ File: app/table_keys.py | Line: 169 | process_table_keys ~ d_json",d_json)
        messages = list()

        json_chunking_thresholds = extract_anchor_thresholds(request_data)
        chunking_dictionary = json_chunking_main(
            request_data["ra_json"], json_chunking_thresholds
        )
        set_redis_data(job_id, "chunking_dictionary", chunking_dictionary)

        try:
            definitions_list = request_data.get("definitions", [])
            definitions = definitions_list[0] if definitions_list else {}
        except:
            definitions = {}

        # For anchors
        json_chunking_thresholds = extract_anchor_thresholds(request_data)

        docs = d_json["nodes"]
        # added by emon on 19/05/2022
        test_document_trigger = None
        try:
            test_document_trigger = request_data["document_id"]
        except:
            pass

        # Primary loop
        for input_doc_idx, target_doc in enumerate(docs):
            try:
                table_definitions = definitions.get("table")

                # If a table node is present without children inside it it is removed from d_json
                try:
                    for x in target_doc["children"]:
                        if ("table" in x["type"]) and (not x["children"]):
                            target_doc["children"].remove(x)
                except:
                    pass

                # Multiple table update
                try:
                    for table_definition in table_definitions:
                        table = None
                        table_id = table_definition.get("table_id")
                        table_name = table_definition.get("table_name")
                        query_key_list = list()
                        table_uniqueID = table_definition.get("table_unique_id")
                        target_def = table_definition.get("table_definition_data")
                        if "keyItems" in target_def.keys():
                            query_key_list = target_def["keyItems"]

                        if not query_key_list:
                            continue
                        empty_columns_trigger = False
                        try:
                            columns = target_def["columns"]
                            if not columns:
                                empty_columns_trigger = True
                        except:
                            pass

                        # Then first check is done to check table is present beforehand( Source is docbulder so file / regular table modes)
                        for x in target_doc["children"]:
                            if (
                                "table" in x["type"]
                                and x.get("table_unique_id") == table_uniqueID
                            ):
                                table = x

                        # Test document trigger handling
                        if (test_document_trigger != None) and (
                            test_document_trigger != target_doc["id"]
                        ):
                            continue

                        # Taking query key list and sending them to key module extraction tools
                        results, messages = extraction_tools_request(
                            query_key_list, request_data, input_doc_idx, messages
                        )

                        # Initiating a cell list
                        cell_list = list()

                        # print(results)

                        # Multiples storage placeholder
                        multiples_storage = dict()

                        # Creating cells and appending them to cell_list
                        for result in results:
                            for key, value in result.items():
                                if value:
                                    if not value["text"]:
                                        continue
                                    cell_dict = dict()
                                    if value.get("title") == "static":
                                        cell_dict["static_value"] = True
                                    cell_dict["label"] = key
                                    cell_dict["pageId"] = value["pageId"]
                                    cell_dict["pos"] = value["pos"]
                                    if value.get("export") == False:
                                        cell_dict["export"] = False
                                    elif value.get("export") == True:
                                        cell_dict["export"] = True
                                    # ommitting keyname and anything before it
                                    text = value["text"]
                                    cell_dict["type"] = "cell"
                                    cell_dict["table_key_generated"] = True
                                    cell_dict["v"] = text

                                    if value.get("qualifierParent"):
                                        cell_dict["qualifierParent"] = value.get(
                                            "qualifierParent"
                                        )

                                    if value.get("originates_from_multiples"):
                                        cell_dict[
                                            "originates_from_multiples"
                                        ] = value.get("originates_from_multiples")
                                        if key in multiples_storage.keys():
                                            multiples_storage[key].append(cell_dict)
                                        else:
                                            multiples_storage[key] = [cell_dict]

                                    else:
                                        cell_list.append(cell_dict)
                        # This is where rows are stored
                        """Only used if no table generated by docbuilder so / GUI does not have table algorithms/keysonly """
                        row_dict_list = list()

                        row_dict = dict()
                        # appending the keyval children list to key mother node
                        if cell_list:
                            row_dict = initiate_blank_row()
                            row_dict["children"] = cell_list
                            row_dict_list = [row_dict]

                        if multiples_storage:
                            max_child_length = get_max_cell_count_of_a_label(
                                multiples_storage
                            )
                            if max_child_length > 1:
                                # This returns, say, we extracted 5 dimensions using anchors in table keys. So, we need 5 rows in tables which are now not present
                                row_dict_list = update_table_with_populated_new_rows(
                                    multiples_storage, max_child_length, row_dict_list
                                )

                            else:
                                for (
                                    label,
                                    associated_cell_list,
                                ) in multiples_storage.items():
                                    for cell in associated_cell_list:
                                        cell_list.append(cell)
                                if cell_list:
                                    row_dict = initiate_blank_row()
                                    row_dict["children"] = cell_list
                                    row_dict_list = [row_dict]

                            """
                            Only for the case when docbuilder so does not produce a table
                            """
                            if len(row_dict_list) > 1:
                                labels_to_create = extract_totals_from_cells(
                                    row_dict_list[0].get("children")
                                )
                                if labels_to_create:
                                    for row_idx, row in enumerate(row_dict_list):
                                        if row_idx > 0:
                                            for x in labels_to_create:
                                                cell_dict = dict()
                                                cell_dict["label"] = x
                                                cell_dict["v"] = "0"
                                                cell_dict["pos"] = ""
                                                cell_dict["type"] = "cell"
                                                cell_dict["pageId"] = ""
                                                row.get("children").append(cell_dict)

                        if multiples_storage and not cell_list:
                            row_dict = initiate_blank_row()
                            row_dict["children"] = row_dict_list

                        table_dict = dict()
                        table_exists_with_empty_children = False

                        if not table:
                            """If table does not exist a table is created"""
                            if row_dict:
                                table_dict["id"] = target_doc["id"] + ".001"
                                table_dict["pos"] = ""
                                table_dict["type"] = "table"
                                table_dict["pageId"] = ""
                                table_dict["table_unique_id"] = table_uniqueID
                                table_dict["table_id"] = table_id
                                table_dict["table_name"] = table_name
                                table_dict["STATUS"] = 0
                                table_dict["children"] = row_dict_list

                                assign_unique_id_helper(table_dict)
                            # If manual table (table does not exist beforehand) -- Seperate process of addition
                            if table_dict:
                                if table_exists_with_empty_children:
                                    if row_dict:
                                        table["children"] = [row_dict]
                                else:
                                    target_doc["children"].append(table_dict)

                        else:
                            try:
                                """
                                Columns are there, but for some positional shifts, no column has been marked,
                                this leads to a table node, with rows, none of the rows containing any marked cell.
                                This falls under how we actually append in case of empty columns
                                """
                                empty_row_count = 0
                                for row_idx, row in enumerate(table["children"]):
                                    cells = row["children"]
                                    empty_row = check_if_empty_row(cells)
                                    if empty_row:
                                        empty_row_count += 1
                                if empty_row_count == len(table["children"]):
                                    empty_columns_trigger = True
                            except:
                                pass
                            if empty_columns_trigger:
                                """Exceptional Case where table node is present but no columns were defined on the GUI
                                If no columns are created/defined on the gui -- We just append the table key generated rows to existing table node children
                                """

                                # Multiple Extraction addition
                                if multiples_storage:
                                    max_child_length = get_max_cell_count_of_a_label(
                                        multiples_storage
                                    )
                                    if max_child_length > 1:
                                        table[
                                            "children"
                                        ] = update_table_with_populated_new_rows(
                                            multiples_storage,
                                            max_child_length,
                                            table["children"],
                                        )

                                    else:
                                        for (
                                            label,
                                            associated_cell_list,
                                        ) in multiples_storage.items():
                                            for cell in associated_cell_list:
                                                cell_list.append(cell)

                                for x in cell_list:
                                    cell = x.copy()
                                    table["children"][0]["children"].append(x)

                                # Assigning unique id
                                assign_unique_id_helper(table)

                            else:
                                """

                                This part of the code deals with the case when docbuilder so does in fact
                                produce a table.


                                """

                                # print("Table found with column present")
                                """ Process to check if the rows do not contain any other cells than none labels
                                If the row has nothing to be displayed on the table, keys do not go there 
                                """

                                first_row = get_first_valid_row(table["children"])

                                for row_idx, row in enumerate(table["children"]):
                                    cells = row["children"]
                                    empty_row = check_if_empty_row(cells)

                                    # print(row_idx, empty_row)
                                    if not empty_row:
                                        for x in cell_list:
                                            cell = x.copy()

                                            if row_idx != first_row:
                                                """Replacing the values"""
                                                cell["v"] = get_replacement_value(cell)

                                            """
                                            Checking if the label was present before and replacing it. If not present
                                            from before appending to the existing cell list (row children)
                                            """
                                            (
                                                already_present,
                                                target_idx,
                                            ) = already_present_function(
                                                row, x["label"]
                                            )
                                            if (
                                                already_present
                                            ):  # Replacing values if cell already present
                                                row["children"][target_idx] = cell
                                            else:  # If not just adding the cell
                                                row["children"].append(cell)

                                # Multiple Extraction addition
                                """
                                Table children (rows) are updating using new table-keys generated cells
                                """

                                if multiples_storage:
                                    max_child_length = get_max_cell_count_of_a_label(
                                        multiples_storage
                                    )
                                    if max_child_length > 1:
                                        table[
                                            "children"
                                        ] = update_table_with_populated_new_rows(
                                            multiples_storage,
                                            max_child_length,
                                            table["children"],
                                        )

                                    else:
                                        for (
                                            label,
                                            associated_cell_list,
                                        ) in multiples_storage.items():
                                            for cell in associated_cell_list:
                                                table["children"][0]["children"].append(
                                                    cell
                                                )

                                    """
                                    Cases where multiple extraction using table-keys generated new rows
                                    but they do not have totals 0 in the later cells for totals. 

                                    This is the case per say, when table-keys were updated, and total fields were created
                                    on the first row, but the rest of the rows still contain total type
                                    fields on the rows (originally created by docbuilder so file) --- They have to transformed
                                    into 0.

                                    So, if docbuilder has gross weight column in 10 rows and user creates a gross weight
                                    using table keys, the section above, updates the first row but the rest of the
                                    grossweights on rest of rows have to replaced with 0.

                                    And that has to be done manually.

                                    """

                                    if extract_totals_from_first_row(table):
                                        rows = table.get("children")
                                        labels_to_create = (
                                            extract_totals_from_first_row(table)
                                        )
                                        for row_idx, row in enumerate(rows):
                                            if row_idx > 0 and row.get("children"):
                                                for x in labels_to_create:
                                                    update_done = False

                                                    while not update_done:
                                                        # Find that cell in the row and make them 0
                                                        for cell in reversed(
                                                            row.get("children")
                                                        ):
                                                            if cell.get("label") == x:
                                                                cell["v"] = "0"
                                                                update_done = True
                                                    # else just append a row
                                                    if not update_done:
                                                        cell_dict = dict()
                                                        cell_dict["label"] = x
                                                        cell_dict["v"] = "0"
                                                        cell_dict["pos"] = ""
                                                        cell_dict["type"] = "cell"
                                                        cell_dict["pageId"] = ""
                                                        row["children"].append(
                                                            cell_dict
                                                        )

                                        table["children"] = rows

                                # Assigning unique id
                                assign_unique_id_helper(table)
                except:
                    print(traceback.print_exc())
                    pass

            except:
                print(traceback.print_exc())
                pass

        data_json = d_json
        result = {"job_id": job_id, "status_code": 200, "messages": messages}
        set_redis_data(job_id, "data_json", data_json)
        publish("process_table_keys_response", "to_pipeline", result)

    except:
        data_json = d_json
        result = {"job_id": job_id, "status_code": 200}
        set_redis_data(job_id, "data_json", data_json)
        publish("process_table_keys_response", "to_pipeline", result)
